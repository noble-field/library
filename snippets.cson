# Your snippets
#
# Atom snippets allow you to enter a simple prefix in the editor and hit tab to
# expand the prefix into a larger code block with templated values.
#
# You can create a new snippet in this file by typing "snip" and then hitting
# tab.
#
# An example CoffeeScript snippet to expand log to console.log:
#
# '.source.coffee':
#   'Console log':
#     'prefix': 'log'
#     'body': 'console.log $1'
#
# Each scope (e.g. '.source.coffee' above) can only be declared once.
#
# This file uses CoffeeScript Object Notation (CSON).
# If you are unfamiliar with CSON, you can read more about it in the
# Atom Flight Manual:
# http://flight-manual.atom.io/using-atom/sections/basic-customization/#_cson
'.source.cpp':
    'Template':
        'prefix': 'template'
        'body':
            """
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)
#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)
#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)
#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)
#define setp(n) fixed << setprecision(n)

template<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }

#define ld long double
#define ll long long
#define vll vector<ll>
#define vi vector<int>
#define pll pair<ll,ll>
#define pi pair<int,int>

#define all(a) (a.begin()),(a.end())
#define rall(a) (a.rbegin()),(a.rend())
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define ins insert

using namespace std;

/* Some Libraries */

//-------------------------------------------------

int main(void)
{
	cin.tie(0);
	ios::sync_with_stdio(false);
    $1
	return 0;
}
            """
    'ModInt':
        'prefix': 'modint'
        'body':"""
//-------------------------------------------------
//--ModInt
//-------------------------------------------------
const ::std::uint_fast64_t MOD = 1e9+7;

class mint
{
private:
    using value_type = ::std::uint_fast64_t;
    value_type n;
public:
    mint():n(0){}
    mint(::std::int_fast64_t _n):n(_n<0 ? MOD-(-_n)%MOD : _n%MOD){}
    mint(const mint &m):n(m.n){}

    friend ::std::ostream& operator<<(::std::ostream &os, const mint &a){
		return os << a.n;
	}
    friend ::std::istream& operator>>(::std::istream &is, mint &a){
        value_type temp; is>>temp;
        a = mint(temp);
        return is;
    }

    mint& operator+=(const mint &m){n+=m.n; n=(n<MOD)?n:n-MOD; return *this;}
    mint& operator-=(const mint &m){n+=MOD-m.n; n=(n<MOD)?n:n-MOD; return *this;}
    mint& operator*=(const mint &m){n=n*m.n%MOD; return *this;}
    mint& operator/=(const mint &m){return *this*=m.inv();}
    mint& operator++(){return *this+=1;}
    mint& operator--(){return *this-=1;}

    mint operator+(const mint &m) const {return mint(*this)+=m;}
    mint operator-(const mint &m) const {return mint(*this)-=m;}
    mint operator*(const mint &m) const {return mint(*this)*=m;}
    mint operator/(const mint &m) const {return mint(*this)/=m;}
    mint operator++(int){mint t(*this); *this+=1; return t;}
    mint operator--(int){mint t(*this); *this-=1; return t;}

    mint operator==(const mint &m) const {return n==m.n;}
    mint operator!=(const mint &m) const {return n!=m.n;}
    mint operator-() const {return mint(MOD-n);}

    mint pow(value_type b) const {
        mint ret(1), m(*this);
        while(b){
            if (b & 1) ret*=m;
            m*=m;
            b>>=1;
        }
        return ret;
    }

    mint inv() const {return pow(MOD-2);}
};
        """
    'Combination':
        'prefix': 'combination'
        'body': """
//-------------------------------------------------
//--Combination (depends on ModInt)
//-------------------------------------------------
class Combination
{
private:
    ::std::vector<mint> _fact;
    ::std::vector<mint> _finv;
public:
    Combination(int n):_fact(n+1), _finv(n+1){
        _fact[0] = _fact[1] = 1;
        _finv[0] = _finv[1] = 1;
        for(int i=2; i<=n; i++){
            _fact[i] = _fact[i-1]*i;
            _finv[i] = _fact[i].inv();
        }
    }
    mint fact(int x){return _fact[x];}
    mint finv(int x){return _finv[x];}
    mint comb(int x, int y){
        if (y>x || y<0) return 0;
        return _fact[x]*_finv[y]*_finv[x-y];
    }
    mint homo(int x, int y){return comb(x+y-1, y);}
};
        """
    'UnionFind':
        'prefix': 'unionfind'
        'body':"""
//-------------------------------------------------
//--Union Find tree
//-------------------------------------------------
class UnionFind
{
private:
    ::std::vector<int> par;
    ::std::vector<int> rank;
public:
    UnionFind(int n):par(n), rank(n){
        for(int i=0; i<n; i++){
            par[i] = i;
            rank[i] = 0;
        }
    }
    int root(int x){
        if (par[x]==x) return x;
        return par[x] = root(par[x]);
    }
    bool same(int x, int y){
        return root(x)==root(y);
    }
    void unite(int x, int y){
        int rx = root(x);
        int ry = root(y);
        if (rx==ry) return;
        if (rank[rx]>rank[ry]){
            par[ry] = rx;
        }else{
            par[rx] = ry;
            if (rx==ry) rank[ry]++;
        }
    }
};
        """
    'SegmentTree':
        'prefix': 'segmenttree'
        'body': """
//-------------------------------------------------
//--Segment tree
//-------------------------------------------------
template<typename T>
class SegmentTree
{
private:
    using F = function<T(T,T)>;
    ::std::vector<T> btree;
    F f, _update;
    T e;
    int n;
public:
    SegmentTree(){}
    SegmentTree(int _n, F f, T e, F g=[](T a,T b){return b;})
         : f(f),e(e),_update(g)
    {
        init(_n);
    }
    SegmentTree(const ::std::vector<T> &v, F f, T e, F g=[](T a,T b){return b;})
         : f(f),e(e),_update(g)
    {
        int _n = v.size();
        init(_n);
        for(int i=0; i<_n; i++) btree[i+n-1] = v[i];
        build();
    }
    void init(int _n){
        n = 1;
        while(_n>n) n<<=1;
        btree.resize(2*n-1, e);
    }
    void build(){
        for(int i=n-2; i>=0; i--) btree[i] = f(btree[2*i+1], btree[2*i+2]);
    }
    void update(int k, T a){
        k += n-1;
        btree[k] = _update(btree[k], a);
        while(k>0){
            --k>>=1;
            btree[k] = f(btree[2*k+1], btree[2*k+2]);
        }
    }
    T query(int a, int b){
        T L=e, R=e;
        a+=n-1; b+=n-1;
        while(a<b){
            if (!(a & 1)) L=f(L, btree[a++]);
            if (!(b & 1)) R=f(btree[--b], R);
            a>>=1; b>>=1;
        }
        return f(L, R);
    }
    T operator[](int k){return btree[k+n-1];}
};
        """
    'BIT':
        'prefix': 'BIT'
        'body': """
//-------------------------------------------------
//--Binary Indexed Tree
//-------------------------------------------------
template<typename T>
class BIT
{
private:
    using F = function<T(T,T)>;
    using G = function<T(T)>;
    const int n;
    ::std::vector<T> data;
    F f; G g; T e;
public:
    BIT(int n, F f, G g, T e):n(n),data(n+1),f(f),g(g),e(e){
        for(int i=1; i<=n; i++) data[i] = e;
    }
    BIT(const ::std::vector<T> &v, F f, G g, T e)
         : n(v.size()),data(v.size()+1),f(f),g(g),e(e)
    {
        for(int i=1; i<=n; i++) data[i] = v[i-1];
        for(int i=1; i<n; i++)
            data[i+(i&-i)] = f(data[i], data[i+(i&-i)]);
    }
    void add(int k, T x){k++;
        for(int i=k; i<=n; i+=i&-i) data[i] = f(data[i], x);
    }
    T query(int k){
        T ret=e;
        for(int i=k; i>0; i-=i&-i) ret = f(ret, data[i]);
        return ret;
    }
    T query(int a, int b){return f(query(b), g(query(a)));}
    void update(int k, T x){
        T upd = f(x, g(query(k, k+1)));
        add(k, upd);
    }
    T operator[](int k){return query(k, k+1);}
};
        """
    'BIT Sum only':
        'prefix': 'BIT Sum only'
        'body': """
//-------------------------------------------------
//--Binary Indexed Tree (Sum only)
//-------------------------------------------------
template<typename T>
class BIT
{
private:
    const int n;
    ::std::vector<T> data;
public:
    BIT(int n):n(n),data(n+1){
        for(int i=1; i<=n; i++) data[i] = 0;
    }
    BIT(const ::std::vector<T> &v):n(v.size()),data(v.size()+1){
        for(int i=1; i<=n; i++) data[i] = v[i-1];
        for(int i=1; i<n; i++)
            data[i+(i&-i)] += data[i];
    }
    void add(int k, T x){k++;
        for(int i=k; i<=n; i+=i&-i) data[i] += x;
    }
    T query(int k){
        T ret=0;
        for(int i=k; i>0; i-=i&-i) ret += data[i];
        return ret;
    }
    T query(int a, int b){return query(b)-query(a);}
    void update(int k, T x){
        T upd = x-query(k, k+1);
        add(k, upd);
    }
    T operator[](int k){return query(k, k+1);}
};
        """
    'Lazy SegmentTree':
        'prefix': 'LazySeg'
        'body': """
//-------------------------------------------------
//--Lazy Evaluation Segment tree (Proportional)
//-------------------------------------------------
template<typename T, typename E>
class LazySegmentTree
{
private:
    using F = ::std::function<T(T,T)>;
    using G = ::std::function<T(T,E)>;
    using H = ::std::function<E(E,E)>;
    F f; G g; H h;
    int n, height;
    ::std::vector<T> seg;
    ::std::vector<E> lazy;
    T te; E ee;
public:
    LazySegmentTree(int _n, F f, G g, H h, T te, E ee)
        : f(f),g(g),h(h),te(te),ee(ee)
    {
        init(_n);
    }
    LazySegmentTree(::std::vector<T> &v, F f, G g, H h, T te, E ee)
        : f(f),g(g),h(h),te(te),ee(ee)
    {
        int _n = v.size();
        init(_n);
        for(int i=n; i<n+_n; i++) seg[i] = v[i-n];
        build();
    }
    void init(int _n){
        n = 1; height=0;
        while(n<_n) n<<=1, height++;
        seg.resize(2*n, te);
        lazy.resize(2*n, ee);
    }
    void build(){
        for(int i=n-1; i>0; i--) seg[i] = f(seg[i<<1], seg[i<<1|1]);
    }
    T eval(int k){
        int c = breadth(k);
        return (lazy[k]==ee) ? seg[k] : g(seg[k],quantify(lazy[k], c));
    }
    void waveto(int k){
        for(int i=height; i>0; i--) wave(k>>i);
    }
    void wave(int k){
        seg[k] = eval(k);
        lazy[k<<1] = h(lazy[k<<1],lazy[k]);
        lazy[k<<1|1] = h(lazy[k<<1|1],lazy[k]);
        lazy[k] = ee;
    }
    void recalc(int k){
        for(int i=1; i<=height; i++){
            int m = k>>i;
            seg[m] = f(eval(m<<1), eval(m<<1|1));
        }
    }
    void update(int a, int b, E x){
        if (b<=a) return;
        waveto(a+=n);
        waveto(b+=n-1);
        T L=ee, R=ee;
        int l=a, r=b;
        while(l<=r){
            if (l&1) lazy[l] = h(lazy[l], x), l++;
            if (!(r&1)) lazy[r] = h(lazy[r], x), r--;
            l>>=1; r>>=1;
        }
        recalc(a);
        recalc(b);
    }
    T query(int a, int b){
        waveto(a+=n);
        waveto(b+=n-1);
        T L=te, R=te;
        int l=a, r=b;
        while(l<=r){
            if (l&1) L = f(L, eval(l++));
            if (!(r&1)) R = f(eval(r--), R);
            l>>=1; r>>=1;
        }
        return f(L,R);
    }
    T operator[](int k){return query(k, k+1);};
    inline int breadth(int k){
        int ret = height-31+__builtin_clz(k);
        return 1<<ret;
    }
    //return value proportional to segment's width
    inline E quantify(E laz, int c){
        return laz;
    }
};
        """
    'RangeSet':
        'prefix': 'RangeSet'
        'body': """
//-------------------------------------------------
//--Range Set Counter
//-------------------------------------------------
template<typename T>
class RangeSet
{
private:
    ::std::vector<int> v;
    ::std::unordered_map<T, int> Map;
    ::std::vector<::std::vector<int> > data;
    int kind;
public:
    RangeSet(const ::std::vector<T> &v_):v(v_.size()){
        int sz = v_.size(); kind = 0;
        for(int i=0;i<sz;i++){
            T t = v_[i];
            if (Map.count(t)){
                data[Map[t]].push_back(i);
            }else{
                Map[t] = kind++;
                data.push_back(::std::vector<int>());
                data.back().push_back(i);
            }
            v[i] = Map[t];
        }
    }
    //query for all elements
    int query(T x){
        if (!Map.count(x)) return 0;
        return data[Map[x]].size();
    }
    //query for [a, b]
    int query(int a, int b, T x){
        if (a>b) return 0;
        if (!Map.count(x)) return 0;
        int xi = Map[x];
        auto right = ::std::upper_bound(data[xi].begin(),data[xi].end(),b);
        auto left  = ::std::lower_bound(data[xi].begin(),data[xi].end(),a);
        return right-left;
    }
    //search x for [k, tail]
    int find(int k, T x){
        if (!Map.count(x)) return -1;
        int xi = Map[x];
        auto itr = ::std::lower_bound(data[xi].begin(),data[xi].end(),k);
        if (itr!=data[xi].end()){
            return *itr;
        }else{
            return -1;
        }
    }
    //update for one point
    void update(int k, T x){
        int ei = v[k];
        auto eitr = ::std::lower_bound(data[ei].begin(),data[ei].end(),k);
        data[ei].erase(eitr);
        v[k] = Map[x];
        if (Map.count(x)){
            int xi = Map[x];
            auto itr = ::std::lower_bound(data[xi].begin(),data[xi].end(),k);
            data[xi].insert(itr, k);
        }else{
            Map[x] = kind++;
            data.push_back(::std::vector<int>());
            data.back().push_back(k);
        }
    }
};
        """
    'Sieve':
        'prefix': 'Sieve'
        'body': """
//-------------------------------------------------
//--Sieve of Eratosthenes
//-------------------------------------------------
class Sieve
{
private:
    ::std::vector<bool> prime;
public:
    Sieve(int n):prime(n+1, true){
        prime[0] = prime[1] = false;
        for(int i=2; i*i<=n; i++){
            if (!prime[i]) continue;
            for(int j=i*2; j<=n; j+=i){
                prime[j] = false;
            }
        }
    }
    bool isprime(int x){return prime[x];}
};
        """
    'Extened GCD':
        'prefix': 'extgcd'
        'body': """
//-------------------------------------------------
//--Extended GCD
//-------------------------------------------------

int_fast64_t extgcd(int_fast64_t a, int_fast64_t b, int_fast64_t &x, int_fast64_t &y)
{
    if (b==0){
        x = 1; y = 0;
        return a;
    }
    int_fast64_t d = extgcd(b,a%b,y,x);
    y -= a/b*x;
    return d;
}
        """
    'Lowest Common Ancestor':
        'prefix': 'LCA'
        'body': """
//-------------------------------------------------
//--Lowest Common Ancestor (depends on Segment tree)
//-------------------------------------------------
class LCA
{
private:
    using Graph = ::std::vector<::std::vector<int> >;
    // using edge = ::std::pair<int,int>;
    // using Graph = ::std::vector<::std::vector<edge> >;
    using P = ::std::pair<int,int>;
    ::std::vector<P> euler;
    ::std::vector<int> fidx;
    int idx;
    SegmentTree<P> seg;
    void dfs(int v, int p, int d, Graph &adj){
        euler.emplace_back(d, v);
        fidx[v] = idx++;
        for(auto u:adj[v]){
            if (u==p) continue;
            dfs(u,v,d+1,adj);
            euler.emplace_back(d, v); idx++;
        }
        // for(auto e:adj[v]){
        //     int u,att;
        //     tie(u,att) = e;
        //     if (u==p) continue;
        //     dfs(u,v,d+1,adj);
        //     euler.emplace_back(d, v); idx++;
        // }
    }
public:
    LCA(int n, Graph &adj):fidx(n){
        idx = 0;
        dfs(0,-1,0,adj);
        seg = SegmentTree<P>(euler, [](P x, P y){return min(x,y);},make_pair(n,n));
    }
    int query(int u, int v){
        int fmin = min(fidx[u],fidx[v]);
        int fmax = max(fidx[u],fidx[v]);
        return seg.query(fmin,fmax+1).second;
    }
};
        """
    'Enumerate':
        'prefix':'Enumerate'
        'body':"""
//-------------------------------------------------
//--Enum various numbers
//-------------------------------------------------
namespace Enum
{
    using fint = ::std::int_fast64_t;
    //素因数分解(素因数列挙)
    ::std::map<fint,int> factor(fint n)
    {
        ::std::map<fint,int> ret;
        for(fint i=2; i*i<=n; i++){
            while(n%i==0){
                ret[i]++;
                n/=i;
            }
        }
        if (n!=1) ret[n]++;
        return ret;
    }
    //約数列挙
    ::std::vector<fint> divisor(fint n)
    {
        ::std::vector<fint> ret;
        for(fint i=1; i*i<=n; i++){
            if (n%i==0){
                ret.push_back(i);
                if (i*i!=n) ret.push_back(n/i);
            }
        }
        return ret;
    }
    //商列挙(割る最小の数と商のペア)
    ::std::vector<::std::pair<fint,fint> > quotient(fint n)
    {
        ::std::vector<::std::pair<fint,fint> > ret;
        fint i=0;
        for(i=1; i*i<=n; i++){
            ret.emplace_back(i,n/i);
        }
        for(; i<=n; i++){
            fint d = n/i;
            ret.emplace_back(i,d);
            i+=(n-d*i)/d;
        }
        return ret;
    }
    //素数判定(おまけ)
    bool isprime(fint n)
    {
        for(fint i=2; i*i<=n; i++){
            if (n%i==0) return false;
        }
        return true;
    }
}
        """
    'Grid BFS':
        'prefix':'Grid BFS'
        'body':"""
//-------------------------------------------------
//--Grid BFS
//-------------------------------------------------

template<typename T>
::std::vector<::std::vector<int> > gBFS(int si, int sj, ::std::vector<::std::vector<T> > &field)
{
    int dx[]={0,1,0,-1};
    int dy[]={1,0,-1,0};
    int h = field.size();
    int w = field[0].size();
    using P = ::std::pair<int,int>;
    ::std::queue<P> que;
    que.emplace(si,sj);
    ::std::vector<::std::vector<int> > dist(h,::std::vector<int>(w,-1));
    dist[si][sj] = 0;
    while(que.size()){
        int x,y;
        tie(y,x) = que.front(); que.pop();
        for(int i=0; i<4; i++){
            int tx = x+dx[i];
            int ty = y+dy[i];
            if (!(0<=tx&&tx<w&&0<=ty&&ty<h)) continue;
            if (dist[ty][tx]!=-1) continue;
            // 壁の条件(任意に書き換える)
            if (field[ty][tx]=='#') continue;
            dist[ty][tx] = dist[y][x]+1;
            que.emplace(ty,tx);
        }
    }
    return dist;
}
        """
    'Heavy Light Decomposition':
        'prefix': 'Heavy Light Decomposition'
        'body': """
//-------------------------------------------------
//--Heavy Light Decomposition
//-------------------------------------------------
class HLD
{
private:
    using Graph = ::std::vector<::std::vector<int> >;
    int n;
    Graph g;
    ::std::vector<int> par, weight, depth;
    ::std::vector<int> head;
    ::std::vector<int> next;
    ::std::vector<int> chain, at;
    ::std::vector<::std::vector<int> > chains;
    void init(){
        par.resize(n);
        weight.resize(n);
        depth.resize(n);
        next.resize(n);
        chain.resize(n);
        at.resize(n);
        head.resize(n);
    }
    void dfs(Graph &g_){
        par[0] = -1;
        depth[0] = 0;
        using P = ::std::pair<int,int>;
        ::std::stack<P> st;
        st.emplace(0,0);
        while(!st.empty()){
            int v = st.top().first;
            int &idx = st.top().second;
            if (idx < g_[v].size()){
                int u = g_[v][idx++];
                if (u==par[v]) continue;
                par[u] = v;
                depth[u] = depth[v]+1;
                st.emplace(u,0);
            }else{
                st.pop();
                int heavy = 0;
                weight[v] = 1;
                for(auto u:g_[v]){
                    if (u==par[v]) continue;
                    weight[v]+=weight[u];
                    if (weight[u]>heavy){
                        heavy = weight[u];
                        next[v] = u;
                    }
                }
            }
        }
    }
    void bfs(Graph &g_){
        int idx=0;
        using P = ::std::pair<int,int>;
        ::std::queue<P> que;
        que.emplace(0,idx++);
        chains.push_back(::std::vector<int>());
        while(!que.empty()){
            int v,c;
            tie(v,c) = que.front(); que.pop();
            chain[v] = c;
            at[v] = chains[c].size();
            chains[c].push_back(v);
            head[v] = chains[c].front();
            for(auto u:g_[v]){
                if (u==par[v]) continue;
                if (u==next[v]){
                    que.emplace(u,c);
                }else{
                    que.emplace(u,idx++);
                    chains.push_back(::std::vector<int>());
                }
            }
        }
    }
    int climb(int v){return par[head[v]];};
public:
    HLD(Graph &g_):n(g_.size()){
        init();
        build(g_);
    }
    HLD(int n_):n(n_),g(n_){init();}
    void add_edge(int a, int b){
        g[a].push_back(b);
        g[b].push_back(a);
    }
    void build(){
        dfs(g);
        bfs(g);
    }
    void build(Graph &g_){
        dfs(g_);
        bfs(g_);
    }
    int lca(int u, int v){
        while(head[u]!=head[v]){
            if (depth[head[u]] > depth[head[v]]){
                u = climb(u);
            }else{
                v = climb(v);
            }
        }
        return (depth[u]<depth[v])?u:v;
    }
};
        """
    'Matrix':
        'prefix': 'Matrix'
        'body': """
//-------------------------------------------------
//--Matrix
//-------------------------------------------------
template<typename T>
class Matrix
{
private:
    using V = ::std::vector<T>;
    using M = ::std::vector<V>;
    M dat;
    int h,w;
public:
    Matrix(int h_, int w_):h(h_),w(w_){
        dat.resize(h,V(w));
    }
    Matrix(const M &mat){
        h = mat.size();
        w = mat[0].size();
        dat.resize(h,V(w));
        for(int i=0; i<h; i++)
            for(int j=0; j<w; j++)
                dat[i][j]=mat[i][j];
    }
    Matrix(const Matrix &m){
        h = m.h; w = m.w;
        dat.resize(h,V(w));
        for(int i=0; i<h; i++)
            for(int j=0; j<w; j++)
                dat[i][j]=m.dat[i][j];
    }
    static Matrix getI(int n){
        Matrix ret(n,n);
        for(int i=0;i<n;i++) ret[i][i] = 1;
        return ret;
    }
    Matrix& operator+=(const Matrix &m){
        assert(m.h==h && m.w==w);
        for(int i=0; i<h; i++)
            for(int j=0; j<w; j++)
                dat[i][j]+=m.dat[i][j];
        return *this;
    }
    Matrix& operator-=(const Matrix &m){
        assert(m.h==h && m.w==w);
        for(int i=0; i<h; i++)
            for(int j=0; j<w; j++)
                dat[i][j]-=m.dat[i][j];
        return *this;
    }
    Matrix& operator*=(const Matrix &m){
        assert(m.h==w);
        M ret(h, V(m.w));
        for(int i=0; i<h; i++)
            for(int j=0; j<m.w; j++)
                for(int k=0; k<w; k++)
                    ret[i][j]+=dat[i][k]*m.dat[k][j];
        dat.swap(ret);
        return *this;
    }
    Matrix& operator*=(T c){
        for(int i=0; i<h; i++)
            for(int j=0; j<w; j++)
                dat[i][j]*=c;
        return *this;
    }
    Matrix& operator^=(::std::uint_fast64_t t){
        assert(h==w);
        Matrix ret = Matrix::getI(h);
        Matrix m(*this);
        while(t){
            if (t&1) ret*=m;
            m*=m;
            t>>=1;
        }
        dat.swap(ret.dat);
        return *this;
    }
    Matrix operator+(const Matrix &m) const {return Matrix(*this)+=m;}
    Matrix operator-(const Matrix &m) const {return Matrix(*this)-=m;}
    Matrix operator*(const Matrix &m) const {return Matrix(*this)*=m;}
    Matrix operator^(const Matrix &m) const {return Matrix(*this)^=m;}
    Matrix operator-() const {return Matrix(*this)*=-1;}
    V& operator[](int h){return dat[h];}
};
        """
